<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Kernel Simulation - Interactive Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .header p { font-size: 1.1em; opacity: 0.9; }
        .controls {
            background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;
            display: flex; gap: 15px; flex-wrap: wrap; align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        button {
            padding: 12px 24px; font-size: 1em; border: none; border-radius: 6px;
            cursor: pointer; transition: all 0.3s ease; font-weight: 600;
        }
        .btn-start {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-start:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4); }
        .btn-start:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-reset { background: #e74c3c; color: white; }
        .btn-reset:hover { background: #c0392b; transform: translateY(-2px); }
        .speed-control { display: flex; align-items: center; gap: 10px; }
        .speed-control label { font-weight: 600; color: #333; }
        .speed-control input { width: 150px; }
        .main-content { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        @media (max-width: 1200px) { .main-content { grid-template-columns: 1fr; } }
        .panel {
            background: white; border-radius: 10px; padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .panel h2 { color: #667eea; margin-bottom: 15px; font-size: 1.3em; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
        .panel h3 { color: #333; margin-top: 15px; margin-bottom: 10px; font-size: 1.1em; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 15px; border-radius: 8px; text-align: center;
        }
        .stat-box .value { font-size: 1.8em; font-weight: bold; }
        .stat-box .label { font-size: 0.9em; opacity: 0.9; margin-top: 5px; }
        .process-list { display: flex; flex-direction: column; gap: 10px; }
        .process-item {
            background: #f8f9fa; border-left: 4px solid #667eea; padding: 12px;
            border-radius: 4px; transition: all 0.3s ease;
        }
        .process-item.running { background: #e8f4f8; border-left-color: #2ecc71; box-shadow: 0 2px 8px rgba(46, 204, 113, 0.2); }
        .process-item.terminated { background: #f0f0f0; border-left-color: #95a5a6; opacity: 0.7; }
        .process-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .process-name { font-weight: 600; color: #333; }
        .process-priority { background: #667eea; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.85em; font-weight: 600; }
        .process-state {
            display: inline-block; padding: 3px 10px; border-radius: 3px; font-size: 0.85em;
            font-weight: 600; margin-top: 5px;
        }
        .state-running { background: #2ecc71; color: white; }
        .state-ready { background: #f39c12; color: white; }
        .state-terminated { background: #95a5a6; color: white; }
        .progress-bar {
            background: #ecf0f1; height: 20px; border-radius: 3px; margin-top: 5px; overflow: hidden;
        }
        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2); height: 100%;
            transition: width 0.3s ease; display: flex; align-items: center;
            justify-content: center; font-size: 0.75em; color: white; font-weight: 600;
        }
        .timeline {
            background: #f8f9fa; border-radius: 8px; padding: 15px;
            max-height: 400px; overflow-y: auto;
        }
        .timeline-event {
            padding: 10px; margin-bottom: 8px; background: white;
            border-left: 3px solid #667eea; border-radius: 3px; font-size: 0.9em; color: #333;
        }
        .timeline-event.scheduler { border-left-color: #3498db; }
        .timeline-event.dispatcher { border-left-color: #2ecc71; }
        .timeline-time { color: #667eea; font-weight: 600; margin-right: 5px; }
        .queue-section { margin-bottom: 15px; }
        .queue-label {
            font-weight: 600; color: #333; margin-bottom: 8px;
            display: flex; align-items: center; gap: 8px;
        }
        .queue-label .count {
            background: #667eea; color: white; padding: 2px 8px;
            border-radius: 3px; font-size: 0.9em;
        }
        .queue-items { display: flex; flex-wrap: wrap; gap: 8px; }
        .queue-item {
            background: #667eea; color: white; padding: 8px 12px;
            border-radius: 6px; font-weight: 600; font-size: 0.9em;
        }
        .thread-info { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px; }
        .thread-box {
            background: #f8f9fa; padding: 12px; border-radius: 8px; border: 2px solid #667eea;
        }
        .thread-name { font-weight: 600; color: #667eea; margin-bottom: 8px; }
        .thread-stat {
            display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.9em;
        }
        .thread-stat .label { color: #666; }
        .thread-stat .value { font-weight: 600; color: #333; }
        .cpu-bar {
            background: white; border-radius: 6px; height: 40px; display: flex;
            align-items: center; justify-content: center; margin-bottom: 10px;
            overflow: hidden; border: 2px solid #ecf0f1;
        }
        .cpu-running {
            background: linear-gradient(90deg, #2ecc71, #27ae60); color: white;
            font-weight: 600; height: 100%; display: flex; align-items: center;
            justify-content: center; animation: pulse 1s infinite;
        }
        .cpu-idle {
            background: #ecf0f1; color: #7f8c8d; font-weight: 600;
            height: 100%; display: flex; align-items: center; justify-content: center;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
        .time-display {
            font-size: 2em; font-weight: bold; color: #667eea;
            text-align: center; padding: 15px; background: #f8f9fa; border-radius: 8px;
        }
        .full-width { grid-column: 1 / -1; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üñ•Ô∏è OS Kernel Simulation</h1>
            <p>Java Logic Running in Browser (2 Concurrent Threads)</p>
        </div>
        
        <div class="controls">
            <button class="btn-start" id="startBtn" onclick="startSimulation()">‚ñ∂Ô∏è Start Simulation</button>
            <button class="btn-reset" id="resetBtn" onclick="resetSimulation()">üîÑ Reset</button>
            <div class="speed-control">
                <label for="speedInput">Dispatcher Speed:</label>
                <input type="range" id="speedInput" min="50" max="300" value="100" step="50">
                <span id="speedValue">100ms</span>
            </div>
        </div>
        
        <div class="main-content">
            <div class="panel">
                <h2>üìã Process & Queue Management</h2>
                <div class="time-display" id="timeDisplay">T = 0</div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="processCount">4</div>
                        <div class="label">Total Processes</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="cpuUsed">0</div>
                        <div class="label">CPU Time Used</div>
                    </div>
                </div>
                
                <div class="queue-section">
                    <div class="queue-label">
                        <span>Ready Queue</span>
                        <span class="count" id="readyQueueCount">4</span>
                    </div>
                    <div class="queue-items" id="readyQueue">
                        <div class="queue-item">P-C (P9)</div>
                        <div class="queue-item">P-A (P8)</div>
                        <div class="queue-item">P-B (P5)</div>
                        <div class="queue-item">P-D (P3)</div>
                    </div>
                </div>
                
                <div class="queue-section">
                    <div class="queue-label">
                        <span>Running Process</span>
                        <span class="count">1</span>
                    </div>
                    <div class="queue-items" id="runningProcess"><div style="color: #999;">None (CPU Idle)</div></div>
                </div>
                
                <h3>Processes</h3>
                <div class="process-list" id="processList"></div>
            </div>
            
            <div class="panel">
                <h2>‚öôÔ∏è CPU & Threading</h2>
                
                <h3>CPU Status</h3>
                <div class="cpu-bar" id="cpuBar">
                    <div class="cpu-idle">CPU Idle</div>
                </div>
                <div style="text-align: center; color: #666; font-size: 0.9em;">
                    Time Slice: <span id="timeSlice">0</span>/3 units
                </div>
                
                <h3>Thread Information</h3>
                <div class="thread-info">
                    <div class="thread-box">
                        <div class="thread-name">üîÑ Scheduler Thread (PID 25)</div>
                        <div class="thread-stat">
                            <span class="label">Cycles:</span>
                            <span class="value" id="schedulerCycles">0</span>
                        </div>
                        <div class="thread-stat">
                            <span class="label">Status:</span>
                            <span class="value" id="schedulerStatus">Waiting</span>
                        </div>
                    </div>
                    
                    <div class="thread-box">
                        <div class="thread-name">‚ö° Dispatcher Thread (PID 26)</div>
                        <div class="thread-stat">
                            <span class="label">Cycles:</span>
                            <span class="value" id="dispatcherCycles">0</span>
                        </div>
                        <div class="thread-stat">
                            <span class="label">Status:</span>
                            <span class="value" id="dispatcherStatus">Waiting</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel full-width">
            <h2>üìä Simulation Timeline</h2>
            <div class="timeline" id="timeline"></div>
        </div>
    </div>
    
    <script>
        const ProcessState = {
            NEW: 'NEW',
            READY: 'READY',
            RUNNING: 'RUNNING',
            BLOCKED: 'BLOCKED',
            TERMINATED: 'TERMINATED'
        };
        
        const sim = {
            processes: [],
            // Ready queues grouped by priority. Highest priority runs first;
            // for processes with the same priority we rotate them (simple RR).
            readyQueuesByPriority: new Map(),
            readyCount: 0,
            scheduledProcess: null, // what the scheduler picked for the dispatcher to run
            currentTime: 0,
            currentRunningProcess: null,
            timeSliceCounter: 0,
            timeQuantum: 3,
            cpuTimeUsed: 0,
            isRunning: false,
            dispatcherSpeed: 100,
            timeline: [],
            
            scheduler: { cycles: 0 },
            dispatcher: { cycles: 0 },
            
            createProcess(name, priority, burstTime) {
                const process = {
                    name: name,
                    priority: priority,
                    burstTime: burstTime,
                    remainingTime: burstTime,
                    state: ProcessState.NEW,
                    startTime: null,
                    endTime: null
                };
                this.processes.push(process);
                return process;
            },

            enqueueReady(process) {
                const p = process.priority;
                if (!this.readyQueuesByPriority.has(p)) this.readyQueuesByPriority.set(p, []);
                this.readyQueuesByPriority.get(p).push(process);
                this.readyCount++;
            },

            dequeueNextReady() {
                if (this.readyCount === 0) return null;
                const priorities = Array.from(this.readyQueuesByPriority.keys()).sort((a, b) => b - a);
                for (const p of priorities) {
                    const q = this.readyQueuesByPriority.get(p);
                    if (q && q.length > 0) {
                        this.readyCount--;
                        return q.shift(); // RR within same priority
                    }
                }
                // Clean-up fallback
                this.readyCount = 0;
                return null;
            },

            // Completion check (same idea as Java): everyone finished, nothing queued,
            // CPU idle and nothing already selected for dispatch.
            isDone() {
                const allTerminated = this.processes.every(p => p.state === ProcessState.TERMINATED);
                return allTerminated && this.readyCount === 0 && !this.currentRunningProcess && !this.scheduledProcess;
            },
            
            // Scheduler logic (simulates the scheduler thread)
            scheduleIfNeeded() {
                // Only pick a new process when CPU is free and there's no pending selection.
                if (this.currentRunningProcess || this.scheduledProcess) return;
                const next = this.dequeueNextReady();
                if (!next) return;
                this.scheduledProcess = next;
                this.addTimelineEvent('scheduler', `SCHEDULE: Selected ${next.name} (P${next.priority}) for dispatch`);
            },
            
            // Run one time unit of the running process (what the dispatcher does)
            executeTimeUnit() {
                if (!this.currentRunningProcess) return;
                this.currentRunningProcess.remainingTime--;
                this.timeSliceCounter++;
                this.cpuTimeUsed++;
                this.addTimelineEvent('dispatcher', `EXECUTE: ${this.currentRunningProcess.name} (Remaining: ${this.currentRunningProcess.remainingTime})`);
            },
            
            // Dispatcher: take the scheduled process (if any), handle preemption/termination,
            // and assign a process to the CPU when idle.
            dispatchStep() {
                // 1) If current process finished
                if (this.currentRunningProcess && this.currentRunningProcess.remainingTime === 0) {
                    this.currentRunningProcess.state = ProcessState.TERMINATED;
                    this.currentRunningProcess.endTime = this.currentTime;
                    this.addTimelineEvent('dispatcher', `PROCESS TERMINATED: ${this.currentRunningProcess.name} completed at time ${this.currentTime}`);
                    this.currentRunningProcess = null;
                    this.timeSliceCounter = 0;
                }
                // 2) If quantum expired (preempt)
                else if (this.currentRunningProcess && this.timeSliceCounter >= this.timeQuantum) {
                    this.addTimelineEvent('dispatcher', `CONTEXT SWITCH: Suspending ${this.currentRunningProcess.name} (quantum expired)`);
                    this.currentRunningProcess.state = ProcessState.READY;
                    this.enqueueReady(this.currentRunningProcess);
                    this.currentRunningProcess = null;
                    this.timeSliceCounter = 0;
                }

                // If CPU is idle and nothing has been selected yet, ask the scheduler immediately.
                // This avoids "...Idle" gaps caused by timer race between two JS intervals.
                if (!this.currentRunningProcess && !this.scheduledProcess) {
                    this.scheduleIfNeeded();
                }

                // 3) If CPU idle and scheduler already selected a process, dispatch it
                if (!this.currentRunningProcess && this.scheduledProcess) {
                    this.currentRunningProcess = this.scheduledProcess;
                    this.scheduledProcess = null;
                    this.currentRunningProcess.state = ProcessState.RUNNING;
                    if (this.currentRunningProcess.startTime === null) {
                        this.currentRunningProcess.startTime = this.currentTime;
                    }
                    this.timeSliceCounter = 0;
                    this.addTimelineEvent('dispatcher', `DISPATCH: ${this.currentRunningProcess.name} assigned to CPU at T=${this.currentTime}`);
                }
            },
            
            // One dispatcher cycle: decide (dispatchStep) then execute one time unit
            runDispatcherCycle() {
                this.dispatchStep();
                this.executeTimeUnit();
            },
            
            addTimelineEvent(type, message) {
                this.timeline.push({ time: this.currentTime, type: type, message: message });
            },
            
            // Reset everything and create initial processes
            initialize() {
                this.processes = [];
                this.readyQueuesByPriority = new Map();
                this.readyCount = 0;
                this.scheduledProcess = null;
                this.currentTime = 0;
                this.currentRunningProcess = null;
                this.timeSliceCounter = 0;
                this.cpuTimeUsed = 0;
                this.scheduler.cycles = 0;
                this.dispatcher.cycles = 0;
                this.timeline = [];
                
                // Create processes. Include a same-priority pair to make Round Robin visible within a priority level.
                this.createProcess('Process-C', 9, 6);
                this.createProcess('Process-A', 8, 12);
                this.createProcess('Process-E', 8, 7);
                this.createProcess('Process-B', 5, 8);
                this.createProcess('Process-D', 3, 10);
                
                // Admit all created processes into the ready queues
                this.processes.forEach(p => {
                    p.state = ProcessState.READY;
                    this.enqueueReady(p);
                });
                
                this.addTimelineEvent('scheduler', 'Simulation started - 5 processes created (includes same-priority RR demo)');
            }
        };
        
        sim.initialize();
        updateUI();

        // Interval IDs so we can restart the dispatcher interval when the user changes speed
        let schedulerIntervalId = null;
        let dispatcherIntervalId = null;
        let checkIntervalId = null;
        
        function startSimulation() {
            if (sim.isRunning) return;
            document.getElementById('startBtn').disabled = true;
            sim.isRunning = true;
            
            // Safety limit only. Real stop condition is: all processes terminated and CPU idle.
            const maxCycles = 500;
            sim.maxCycles = maxCycles;

            let lastLoggedTime = -1;

            function isAllDone() {
                const allTerminated = sim.processes.every(p => p.state === ProcessState.TERMINATED || p.remainingTime <= 0);
                const cpuIdle = !sim.currentRunningProcess;
                const nothingQueued = (sim.readyCount === 0) && !sim.scheduledProcess;
                return allTerminated && cpuIdle && nothingQueued;
            }
            
            // Scheduler 'thread' (interval) ‚Äî tries to pick a process when CPU is free
            schedulerIntervalId = setInterval(() => {
                if (sim.scheduler.cycles >= maxCycles || !sim.isRunning) {
                    clearInterval(schedulerIntervalId);
                    return;
                }
                sim.scheduler.cycles++;
                sim.scheduleIfNeeded();

                // Log only when time changes to avoid spam when scheduler interval is faster.
                if (sim.currentTime !== lastLoggedTime) {
                    lastLoggedTime = sim.currentTime;
                    const ready = sim.readyCount;
                    const running = sim.currentRunningProcess ? 1 : 0;
                    const terminated = sim.processes.filter(p => p.state === ProcessState.TERMINATED || p.remainingTime <= 0).length;
                    sim.addTimelineEvent('scheduler', `[PID 25] Ready Queue: ${ready}, Running: ${running}, Terminated: ${terminated}`);
                }
                updateUI();
            }, 120);
            
            // Dispatcher 'thread' (interval) ‚Äî runs CPU cycles independently
            dispatcherIntervalId = setInterval(() => {
                if (sim.dispatcher.cycles >= maxCycles || !sim.isRunning) {
                    clearInterval(dispatcherIntervalId);
                    return;
                }
                sim.dispatcher.cycles++;
                sim.runDispatcherCycle();
                sim.currentTime++;
                updateUI();
            }, sim.dispatcherSpeed);
            
            // Small monitor: stop everything when simulation is done
            checkIntervalId = setInterval(() => {
                if (!sim.isRunning || isAllDone() || (sim.scheduler.cycles >= maxCycles && sim.dispatcher.cycles >= maxCycles)) {
                    clearInterval(schedulerIntervalId);
                    clearInterval(dispatcherIntervalId);
                    clearInterval(checkIntervalId);
                    sim.isRunning = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('startBtn').textContent = '‚úì Completed';
                    updateUI();
                }
            }, 50);
        }
        
        function resetSimulation() {
            sim.isRunning = false;
            if (schedulerIntervalId) clearInterval(schedulerIntervalId);
            if (dispatcherIntervalId) clearInterval(dispatcherIntervalId);
            if (checkIntervalId) clearInterval(checkIntervalId);
            sim.initialize();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = '‚ñ∂Ô∏è Start Simulation';
            updateUI();
        }
        
        document.getElementById('speedInput').addEventListener('input', (e) => {
            sim.dispatcherSpeed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = sim.dispatcherSpeed + 'ms';

            // Apply speed immediately while running by restarting dispatcher interval
            if (sim.isRunning && dispatcherIntervalId) {
                clearInterval(dispatcherIntervalId);
                dispatcherIntervalId = setInterval(() => {
                    if (sim.isDone() || sim.dispatcher.cycles >= (sim.maxCycles ?? 500) || !sim.isRunning) {
                        clearInterval(dispatcherIntervalId);
                        return;
                    }
                    sim.dispatcher.cycles++;
                    sim.runDispatcherCycle();
                    sim.currentTime++;
                    updateUI();
                }, sim.dispatcherSpeed);
            }
        });
        
        function updateUI() {
            document.getElementById('timeDisplay').textContent = `T = ${sim.currentTime}`;
            document.getElementById('processCount').textContent = sim.processes.length;
            document.getElementById('cpuUsed').textContent = sim.cpuTimeUsed;
            document.getElementById('readyQueueCount').textContent = sim.readyCount;

            // Flatten ready queues in priority order for display
            const priorities = Array.from(sim.readyQueuesByPriority.keys()).sort((a, b) => b - a);
            const flatReady = [];
            for (const pr of priorities) {
                const q = sim.readyQueuesByPriority.get(pr) || [];
                for (const p of q) flatReady.push(p);
            }
            const readyHtml = flatReady.map(p => `<div class="queue-item">${p.name} (P${p.priority})</div>`).join('');
            document.getElementById('readyQueue').innerHTML = readyHtml || '<div style="color: #999;">Empty</div>';
            
            const runningHtml = sim.currentRunningProcess ? 
                `<div class="queue-item" style="background: #2ecc71;">${sim.currentRunningProcess.name}</div>` :
                '<div style="color: #999;">None (CPU Idle)</div>';
            document.getElementById('runningProcess').innerHTML = runningHtml;
            
            const cpuBarHtml = sim.currentRunningProcess ?
                `<div class="cpu-running">${sim.currentRunningProcess.name}</div>` :
                '<div class="cpu-idle">CPU Idle</div>';
            document.getElementById('cpuBar').innerHTML = cpuBarHtml;
            document.getElementById('timeSlice').textContent = sim.timeSliceCounter;
            
            document.getElementById('schedulerCycles').textContent = sim.scheduler.cycles;
            document.getElementById('dispatcherCycles').textContent = sim.dispatcher.cycles;
            document.getElementById('schedulerStatus').textContent = sim.isRunning ? 'Running' : 'Idle';
            document.getElementById('dispatcherStatus').textContent = sim.isRunning ? 'Running' : 'Idle';
            
            const processHtml = sim.processes.map(p => {
                const pct = ((p.burstTime - p.remainingTime) / p.burstTime) * 100;
                const displayState = p.remainingTime <= 0 ? ProcessState.TERMINATED : p.state;
                return `
                    <div class="process-item ${displayState === ProcessState.RUNNING ? 'running' : displayState === ProcessState.TERMINATED ? 'terminated' : ''}">
                        <div class="process-header">
                            <span class="process-name">${p.name}</span>
                            <span class="process-priority">P${p.priority}</span>
                        </div>
                        <div class="process-state state-${displayState.toLowerCase()}">${displayState}</div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">
                            Remaining: ${p.remainingTime} / ${p.burstTime}
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${pct}%">${Math.round(pct)}%</div>
                        </div>
                    </div>
                `;
            }).join('');
            document.getElementById('processList').innerHTML = processHtml;
            
            const timelineHtml = sim.timeline.slice(-15).reverse().map(e => `
                <div class="timeline-event ${e.type}">
                    <span class="timeline-time">[T=${e.time}]</span>
                    <strong>${e.type === 'scheduler' ? 'üîÑ' : '‚ö°'}</strong> ${e.message}
                </div>
            `).join('');
            document.getElementById('timeline').innerHTML = timelineHtml;
        }
    </script>
</body>
</html>
