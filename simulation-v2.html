<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Kernel Simulation - Interactive Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .header p { font-size: 1.1em; opacity: 0.9; }
        .controls {
            background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;
            display: flex; gap: 15px; flex-wrap: wrap; align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        button {
            padding: 12px 24px; font-size: 1em; border: none; border-radius: 6px;
            cursor: pointer; transition: all 0.3s ease; font-weight: 600;
        }
        .btn-start {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-start:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4); }
        .btn-start:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-reset { background: #e74c3c; color: white; }
        .btn-reset:hover { background: #c0392b; transform: translateY(-2px); }
        .speed-control { display: flex; align-items: center; gap: 10px; }
        .speed-control label { font-weight: 600; color: #333; }
        .speed-control input { width: 150px; }
        .main-content { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        @media (max-width: 1200px) { .main-content { grid-template-columns: 1fr; } }
        .panel {
            background: white; border-radius: 10px; padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .panel h2 { color: #667eea; margin-bottom: 15px; font-size: 1.3em; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
        .panel h3 { color: #333; margin-top: 15px; margin-bottom: 10px; font-size: 1.1em; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 15px; border-radius: 8px; text-align: center;
        }
        .stat-box .value { font-size: 1.8em; font-weight: bold; }
        .stat-box .label { font-size: 0.9em; opacity: 0.9; margin-top: 5px; }
        .process-list { display: flex; flex-direction: column; gap: 10px; }
        .process-item {
            background: #f8f9fa; border-left: 4px solid #667eea; padding: 12px;
            border-radius: 4px; transition: all 0.3s ease;
        }
        .process-item.running { background: #e8f4f8; border-left-color: #2ecc71; box-shadow: 0 2px 8px rgba(46, 204, 113, 0.2); }
        .process-item.terminated { background: #f0f0f0; border-left-color: #95a5a6; opacity: 0.7; }
        .process-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .process-name { font-weight: 600; color: #333; }
        .process-priority { background: #667eea; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.85em; font-weight: 600; }
        .process-state {
            display: inline-block; padding: 3px 10px; border-radius: 3px; font-size: 0.85em;
            font-weight: 600; margin-top: 5px;
        }
        .state-running { background: #2ecc71; color: white; }
        .state-ready { background: #f39c12; color: white; }
        .state-terminated { background: #95a5a6; color: white; }
        .progress-bar {
            background: #ecf0f1; height: 20px; border-radius: 3px; margin-top: 5px; overflow: hidden;
        }
        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2); height: 100%;
            transition: width 0.3s ease; display: flex; align-items: center;
            justify-content: center; font-size: 0.75em; color: white; font-weight: 600;
        }
        .timeline {
            background: #f8f9fa; border-radius: 8px; padding: 15px;
            max-height: 400px; overflow-y: auto;
        }
        .timeline-event {
            padding: 10px; margin-bottom: 8px; background: white;
            border-left: 3px solid #667eea; border-radius: 3px; font-size: 0.9em; color: #333;
        }
        .timeline-event.scheduler { border-left-color: #3498db; }
        .timeline-event.dispatcher { border-left-color: #2ecc71; }
        .timeline-time { color: #667eea; font-weight: 600; margin-right: 5px; }
        .queue-section { margin-bottom: 15px; }
        .queue-label {
            font-weight: 600; color: #333; margin-bottom: 8px;
            display: flex; align-items: center; gap: 8px;
        }
        .queue-label .count {
            background: #667eea; color: white; padding: 2px 8px;
            border-radius: 3px; font-size: 0.9em;
        }
        .queue-items { display: flex; flex-wrap: wrap; gap: 8px; }
        .queue-item {
            background: #667eea; color: white; padding: 8px 12px;
            border-radius: 6px; font-weight: 600; font-size: 0.9em;
        }
        .thread-info { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px; }
        .thread-box {
            background: #f8f9fa; padding: 12px; border-radius: 8px; border: 2px solid #667eea;
        }
        .thread-name { font-weight: 600; color: #667eea; margin-bottom: 8px; }
        .thread-stat {
            display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.9em;
        }
        .thread-stat .label { color: #666; }
        .thread-stat .value { font-weight: 600; color: #333; }
        .cpu-bar {
            background: white; border-radius: 6px; height: 40px; display: flex;
            align-items: center; justify-content: center; margin-bottom: 10px;
            overflow: hidden; border: 2px solid #ecf0f1;
        }
        .cpu-running {
            background: linear-gradient(90deg, #2ecc71, #27ae60); color: white;
            font-weight: 600; height: 100%; display: flex; align-items: center;
            justify-content: center; animation: pulse 1s infinite;
        }
        .cpu-idle {
            background: #ecf0f1; color: #7f8c8d; font-weight: 600;
            height: 100%; display: flex; align-items: center; justify-content: center;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
        .time-display {
            font-size: 2em; font-weight: bold; color: #667eea;
            text-align: center; padding: 15px; background: #f8f9fa; border-radius: 8px;
        }
        .full-width { grid-column: 1 / -1; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üñ•Ô∏è OS Kernel Simulation</h1>
            <p>Java Logic Running in Browser (2 Concurrent Threads)</p>
        </div>
        
        <div class="controls">
            <button class="btn-start" id="startBtn" onclick="startSimulation()">‚ñ∂Ô∏è Start Simulation</button>
            <button class="btn-reset" id="resetBtn" onclick="resetSimulation()">üîÑ Reset</button>
            <div class="speed-control">
                <label for="speedInput">Dispatcher Speed:</label>
                <input type="range" id="speedInput" min="50" max="300" value="100" step="50">
                <span id="speedValue">100ms</span>
            </div>
        </div>
        
        <div class="main-content">
            <div class="panel">
                <h2>üìã Process & Queue Management</h2>
                <div class="time-display" id="timeDisplay">T = 0</div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="processCount">4</div>
                        <div class="label">Total Processes</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="cpuUsed">0</div>
                        <div class="label">CPU Time Used</div>
                    </div>
                </div>
                
                <div class="queue-section">
                    <div class="queue-label">
                        <span>Ready Queue</span>
                        <span class="count" id="readyQueueCount">4</span>
                    </div>
                    <div class="queue-items" id="readyQueue">
                        <div class="queue-item">P-C (P9)</div>
                        <div class="queue-item">P-A (P8)</div>
                        <div class="queue-item">P-B (P5)</div>
                        <div class="queue-item">P-D (P3)</div>
                    </div>
                </div>
                
                <div class="queue-section">
                    <div class="queue-label">
                        <span>Running Process</span>
                        <span class="count">1</span>
                    </div>
                    <div class="queue-items" id="runningProcess"><div style="color: #999;">None (CPU Idle)</div></div>
                </div>
                
                <h3>Processes</h3>
                <div class="process-list" id="processList"></div>
            </div>
            
            <div class="panel">
                <h2>‚öôÔ∏è CPU & Threading</h2>
                
                <h3>CPU Status</h3>
                <div class="cpu-bar" id="cpuBar">
                    <div class="cpu-idle">CPU Idle</div>
                </div>
                <div style="text-align: center; color: #666; font-size: 0.9em;">
                    Time Slice: <span id="timeSlice">0</span>/3 units
                </div>
                
                <h3>Thread Information</h3>
                <div class="thread-info">
                    <div class="thread-box">
                        <div class="thread-name">üîÑ Scheduler Thread (PID 25)</div>
                        <div class="thread-stat">
                            <span class="label">Cycles:</span>
                            <span class="value" id="schedulerCycles">0</span>
                        </div>
                        <div class="thread-stat">
                            <span class="label">Status:</span>
                            <span class="value" id="schedulerStatus">Waiting</span>
                        </div>
                    </div>
                    
                    <div class="thread-box">
                        <div class="thread-name">‚ö° Dispatcher Thread (PID 26)</div>
                        <div class="thread-stat">
                            <span class="label">Cycles:</span>
                            <span class="value" id="dispatcherCycles">0</span>
                        </div>
                        <div class="thread-stat">
                            <span class="label">Status:</span>
                            <span class="value" id="dispatcherStatus">Waiting</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel full-width">
            <h2>üìä Simulation Timeline</h2>
            <div class="timeline" id="timeline"></div>
        </div>
    </div>
    
    <script>
        const ProcessState = {
            NEW: 'NEW',
            READY: 'READY',
            RUNNING: 'RUNNING',
            BLOCKED: 'BLOCKED',
            TERMINATED: 'TERMINATED'
        };
        
        const sim = {
            processes: [],
            readyQueue: [],
            currentTime: 0,
            currentRunningProcess: null,
            timeSliceCounter: 0,
            timeQuantum: 3,
            cpuTimeUsed: 0,
            isRunning: false,
            dispatcherSpeed: 100,
            timeline: [],
            
            scheduler: { cycles: 0 },
            dispatcher: { cycles: 0 },
            
            createProcess(name, priority, burstTime) {
                const process = {
                    name: name,
                    priority: priority,
                    burstTime: burstTime,
                    remainingTime: burstTime,
                    state: ProcessState.NEW,
                    startTime: null,
                    endTime: null
                };
                this.processes.push(process);
                return process;
            },
            
            getNextProcess() {
                if (this.readyQueue.length === 0) return null;
                // Priority-based: highest priority first
                let maxPriority = -1;
                let selectedIndex = -1;
                for (let i = 0; i < this.readyQueue.length; i++) {
                    if (this.readyQueue[i].priority > maxPriority) {
                        maxPriority = this.readyQueue[i].priority;
                        selectedIndex = i;
                    }
                }
                const process = this.readyQueue.splice(selectedIndex, 1)[0];
                return process;
            },
            
            // Execute one unit (Java executeTimeUnit)
            executeTimeUnit() {
                if (this.currentRunningProcess) {
                    this.currentRunningProcess.remainingTime--;
                    this.timeSliceCounter++;
                    this.cpuTimeUsed++;
                    this.addTimelineEvent('dispatcher', `EXECUTE: ${this.currentRunningProcess.name} (Remaining: ${this.currentRunningProcess.remainingTime})`);
                }
            },
            
            // Dispatch (Java dispatch logic)
            dispatch() {
                // Check if process complete
                if (this.currentRunningProcess && this.currentRunningProcess.remainingTime === 0) {
                    this.currentRunningProcess.state = ProcessState.TERMINATED;
                    this.currentRunningProcess.endTime = this.currentTime;
                    this.addTimelineEvent('dispatcher', `PROCESS TERMINATED: ${this.currentRunningProcess.name} completed at time ${this.currentTime}`);
                    this.currentRunningProcess = null;
                    this.timeSliceCounter = 0;
                }
                // Check if quantum expired
                else if (this.currentRunningProcess && this.timeSliceCounter >= this.timeQuantum) {
                    this.addTimelineEvent('dispatcher', `CONTEXT SWITCH: Suspending ${this.currentRunningProcess.name} (quantum expired)`);
                    this.currentRunningProcess.state = ProcessState.READY;
                    this.readyQueue.push(this.currentRunningProcess);
                    this.currentRunningProcess = null;
                    this.timeSliceCounter = 0;
                }
                
                // Select next process
                if (!this.currentRunningProcess && this.readyQueue.length > 0) {
                    this.currentRunningProcess = this.getNextProcess();
                    if (this.currentRunningProcess) {
                        this.currentRunningProcess.state = ProcessState.RUNNING;
                        if (!this.currentRunningProcess.startTime) {
                            this.currentRunningProcess.startTime = this.currentTime;
                        }
                        this.timeSliceCounter = 0;
                        this.addTimelineEvent('dispatcher', `DISPATCH: ${this.currentRunningProcess.name} assigned to CPU at T=${this.currentTime}`);
                    }
                }
            },
            
            // Run cycle (Java runCycle: dispatch then execute)
            runCycle() {
                this.dispatch();
                this.executeTimeUnit();
            },
            
            addTimelineEvent(type, message) {
                this.timeline.push({ time: this.currentTime, type: type, message: message });
            },
            
            initialize() {
                this.processes = [];
                this.readyQueue = [];
                this.currentTime = 0;
                this.currentRunningProcess = null;
                this.timeSliceCounter = 0;
                this.cpuTimeUsed = 0;
                this.scheduler.cycles = 0;
                this.dispatcher.cycles = 0;
                this.timeline = [];
                
                // Create 4 processes
                this.createProcess('Process-C', 9, 6);
                this.createProcess('Process-A', 8, 12);
                this.createProcess('Process-B', 5, 8);
                this.createProcess('Process-D', 3, 10);
                
                // Move to ready queue
                this.processes.forEach(p => {
                    p.state = ProcessState.READY;
                    this.readyQueue.push(p);
                });
                
                this.addTimelineEvent('scheduler', 'Simulation started - 4 processes created');
            }
        };
        
        sim.initialize();
        updateUI();
        
        function startSimulation() {
            if (sim.isRunning) return;
            document.getElementById('startBtn').disabled = true;
            sim.isRunning = true;
            
            const maxCycles = 50;
            let schedulerCycles = 0;
            let dispatcherCycles = 0;
            
            // SCHEDULER THREAD - every 120ms
            const schedulerInterval = setInterval(() => {
                if (schedulerCycles >= maxCycles || !sim.isRunning) {
                    clearInterval(schedulerInterval);
                    return;
                }
                sim.scheduler.cycles++;
                const ready = sim.readyQueue.length;
                const running = sim.currentRunningProcess ? 1 : 0;
                const terminated = sim.processes.filter(p => p.state === ProcessState.TERMINATED).length;
                sim.addTimelineEvent('scheduler', `[PID 25] Ready Queue: ${ready}, Running: ${running}, Terminated: ${terminated}`);
                schedulerCycles++;
                updateUI();
            }, 120);
            
            // DISPATCHER THREAD - runs independently
            const dispatcherInterval = setInterval(() => {
                if (dispatcherCycles >= maxCycles || !sim.isRunning) {
                    clearInterval(dispatcherInterval);
                    return;
                }
                sim.dispatcher.cycles++;
                sim.runCycle();
                sim.currentTime++;
                dispatcherCycles++;
                updateUI();
            }, sim.dispatcherSpeed);
            
            // Stop when both complete
            const checkInterval = setInterval(() => {
                if (!sim.isRunning || (schedulerCycles >= maxCycles && dispatcherCycles >= maxCycles)) {
                    clearInterval(schedulerInterval);
                    clearInterval(dispatcherInterval);
                    clearInterval(checkInterval);
                    sim.isRunning = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('startBtn').textContent = '‚úì Completed';
                    updateUI();
                }
            }, 50);
        }
        
        function resetSimulation() {
            sim.isRunning = false;
            sim.initialize();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = '‚ñ∂Ô∏è Start Simulation';
            updateUI();
        }
        
        document.getElementById('speedInput').addEventListener('input', (e) => {
            sim.dispatcherSpeed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = sim.dispatcherSpeed + 'ms';
        });
        
        function updateUI() {
            document.getElementById('timeDisplay').textContent = `T = ${sim.currentTime}`;
            document.getElementById('processCount').textContent = sim.processes.length;
            document.getElementById('cpuUsed').textContent = sim.cpuTimeUsed;
            document.getElementById('readyQueueCount').textContent = sim.readyQueue.length;
            
            const readyHtml = sim.readyQueue.map(p => `<div class="queue-item">${p.name} (P${p.priority})</div>`).join('');
            document.getElementById('readyQueue').innerHTML = readyHtml || '<div style="color: #999;">Empty</div>';
            
            const runningHtml = sim.currentRunningProcess ? 
                `<div class="queue-item" style="background: #2ecc71;">${sim.currentRunningProcess.name}</div>` :
                '<div style="color: #999;">None (CPU Idle)</div>';
            document.getElementById('runningProcess').innerHTML = runningHtml;
            
            const cpuBarHtml = sim.currentRunningProcess ?
                `<div class="cpu-running">${sim.currentRunningProcess.name}</div>` :
                '<div class="cpu-idle">CPU Idle</div>';
            document.getElementById('cpuBar').innerHTML = cpuBarHtml;
            document.getElementById('timeSlice').textContent = sim.timeSliceCounter;
            
            document.getElementById('schedulerCycles').textContent = sim.scheduler.cycles;
            document.getElementById('dispatcherCycles').textContent = sim.dispatcher.cycles;
            document.getElementById('schedulerStatus').textContent = sim.isRunning ? 'Running' : 'Idle';
            document.getElementById('dispatcherStatus').textContent = sim.isRunning ? 'Running' : 'Idle';
            
            const processHtml = sim.processes.map(p => {
                const pct = ((p.burstTime - p.remainingTime) / p.burstTime) * 100;
                const displayState = p.remainingTime <= 0 ? ProcessState.TERMINATED : p.state;
                return `
                    <div class="process-item ${displayState === ProcessState.RUNNING ? 'running' : displayState === ProcessState.TERMINATED ? 'terminated' : ''}">
                        <div class="process-header">
                            <span class="process-name">${p.name}</span>
                            <span class="process-priority">P${p.priority}</span>
                        </div>
                        <div class="process-state state-${displayState.toLowerCase()}">${displayState}</div>
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">
                            Remaining: ${p.remainingTime} / ${p.burstTime}
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${pct}%">${Math.round(pct)}%</div>
                        </div>
                    </div>
                `;
            }).join('');
            document.getElementById('processList').innerHTML = processHtml;
            
            const timelineHtml = sim.timeline.slice(-15).reverse().map(e => `
                <div class="timeline-event ${e.type}">
                    <span class="timeline-time">[T=${e.time}]</span>
                    <strong>${e.type === 'scheduler' ? 'üîÑ' : '‚ö°'}</strong> ${e.message}
                </div>
            `).join('');
            document.getElementById('timeline').innerHTML = timelineHtml;
        }
    </script>
</body>
</html>
